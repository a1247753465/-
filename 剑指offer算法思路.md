[toc]
## 查找数组中重复的数字

- 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

- 思路：javascript中Set识别重复数值作用，可以通过判断添加到Set集合中的之前的size和之后的size进行比较，长度一致则是重复的数字

## 二维数组中的查找

- 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

- 思路：重下往上找，首先比较每行首位与目标的大小，if 首位>target:i--; if 首位<target:j++;否则返回true

## 从尾到头打印链表

- 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

- 思路一：将链表中的值放入一个数组，在使用reverse()将数组中的值反转

- 思路二：
 + 重新定义两个指针p,tem;
 + p->head.next,tem->p.next
 + 将p和head指针方向改变
 + head前移

## 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7

思路：使用分治思想，通过前序遍历数组中找到根节点，再遍历中序数组将左右子树元素划分出来，将中序区分出来的数组看成一个新的二叉树，不断地递归直到左右子树为null时返回

## 用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

示例 1：

输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]

思路：利用栈的“后入先出”,定义两个栈，入栈和出栈，入栈将值放入，出栈将值输出，进行deleteHead操作时，将入栈中的值通过pop逐个放入出栈，再输出出栈的值

## 斐波那契数列

写一个函数，输入n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例 1：

输入：n = 2
输出：1

示例 2：

输入：n = 5
输出：5

思路：注意需要取模（求余），公式如上面

## 青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例 1：

输入：n = 2
输出：2

示例 2：

输入：n = 7
输出：21

思路：注意取模，首先确定边界问题，当n=0, out=1; 当n=1, out=1; 当n=2, out=2, 当n>=3时，fib(n) = fib(n-1) + fib(n-2)

## 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

示例 1：

输入：[3,4,5,1,2]
输出：1

示例 2：

输入：[2,2,2,0,1]
输出：0

思路1： 使用Math.min(...numbers)找出最小的值

思路2： 使用二分法，当i===j时，j--解决两者相等平分问题

## 矩阵中的路径

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

思路：利用深度优先遍历和回溯思想来解决问题，首先判断矩阵中是否有第一个字母，若存在，以当前字母在矩阵中的位置呈现+，即距离中心一格（上下左右），不断递归找出下一个存在下一个字母的位置，再利用同样的思想直到没有字母为止就成功返回，利用路径标识（对象）来记录是否走过则条路径
识别条件：

- 判断路径是否走过
- 中心位置是否超出矩阵长度
- 判断当前位置是否是指定的字母

## 机器人的运动范围

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

输入：m = 2, n = 3, k = 1
输出：3

输入：m = 3, n = 1, k = 0
输出：1

思路：利用广度优先遍历解决问题，可以将该问题看成一个乘法口诀表，只走在斜线范围内的路径，适用于广度优先遍历，一旦不满足条件便不会往该路径更深的方向走去；注意该题目是位数之和来计算；知识点：+"1"会自动转化为1

## 左旋转字符串

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

示例 1：

输入: s = "abcdefg", k = 2
输出: "cdefgab"
示例 2：

输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"

思路: 使用slice将指定的位置到后面的字符串加上前面字符串

## 链表倒数第k个节点

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

示例：

给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.

思路：使用两个指针p、q，让p先走k步，再让q走，直到p走完结束循环

## 打印从1到最大的n位数

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

示例 1:

输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]

思路1：使用`**`运算法解决
思路2：使用为运算符>>遇到最后一位的位数为1是sum*=base,同时base*=base，且往右移一位,否则只是base*=base,且往右移一位

## 二叉树镜像

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

例如输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
镜像输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1

示例 1：

输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]

思路：利用递归思想，将左右两边互换，再将左右孩子当成新的节点进行递归

## 二叉树的深度

输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

例如：

给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。

思路：利用递归思想，该节点不为空，num的初始值为1，递归左孩子的深度和递归右孩子的深度，将两个孩子的深度比较最大值，再加上num,返回num就是二叉树的深度

## 反转链表

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

思路：利用双指针，使用tmp保存反转链表，p指向head,不断遍历p,q指针指向p.next,用于保存下一个要拆分的节点，p.next=tmp形成新的反转链表，tmp=p保存反转链表,p=q指向下一个要拆分的节点

## 合并两个排序的链表

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

示例1：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

思路：新建一个node用于保存合并链表，比较l1和l2的val大小，小的拼接到node,同时小的链表往下走直到其中一个链表遍历完，再将没有为空的链表拼接上

## 二进制中1的个数

请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

示例 1：

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：

输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

思路：利用n = n & (n-1)消除n中最后一位1

## 二叉搜索树的第K大节点

给定一棵二叉搜索树，请找出其中第k大的节点。

示例 1:

输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
示例 2:

输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4

思路：根据输入的二叉树，逆中序遍历可以取得递减序列，即右-顶-左，利用递归思想，先将右孩子遍历完，得到第一个右孩子值最大，判断k是否为0，为0直接返回，否则k--,直到k=0时取出第k大的值，同时遍历左孩子

## 和为S的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

示例 1：

输入：target = 9
输出：[[2,3,4],[4,5]]
示例 2：

输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]

思路：利用窗口滑动，窗口滑动就是每次向右滑动时，窗口右侧进入的新元素减去左侧退出的旧元素，得到的结果与上次的和相加得到新的和；这道题就是将index=target/2上取整，从1到index,即窗口左侧放入窗口，当放入窗口中的值之和大于9，就将左侧的值删除，直到等于9再放入res数组中

## 从上到下打印二叉树

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]

思路：使用队列保存当前层次的节点，使用两个while，第一个记录level层级，第二个将当前层级的节点值放进去，res[level] = []用来记录层级的节点值，取出root.val放入res[level],同时将queue中前面一个节点去掉，再将左右孩子放入queue

## 数组中出现次数超过一半的数字

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1:

输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2

思路：利用摩尔投票法，摩尔投票法就是正负相互抵消，最终还剩下那个就是次数超过一半的数字,要求所要找的数字必须占一半以上；这道题解使用count=1来记录当前正极出现次数多的数字，当count=0时，切换另一个数字，当major==nums[i],count++;否则count--,最后输出major就是出现次数最多的数字

## 和为s的两个数字

输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
示例 2：

输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]

思路：利用对撞指针思想，将i,j设置为数组两端，循环i<j,s=nums[i]+nums[j],当s>target,j--,当s<target,i++,当s=target,返回数组

## 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

示例：

输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。

思路：利用对撞指针思想，将i,j设置为数组两端，循环i<j,循环nums[i]%2===1,++i;循环nums[j]%2===0,--j;然后交换

## 两个链表的第一个公共节点

输入两个链表，找出它们的第一个公共节点。

如下面的两个链表：

![](./picture/same_ponit.png)

在节点 c1 开始相交。

示例 1：

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

思路：浪漫相遇，利用两个指针node1、node2指向headA、headB,让node1、node2往下走，当node1=null时，node1=headB,当node2=null时，node2=headB;两者都走过对方的路，最后在第一个公共点浪漫相遇

## 圆圈中最后剩下的数字

0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

示例 1：

输入: n = 5, m = 3
输出: 3
示例 2：

输入: n = 10, m = 17
输出: 2

思路：约瑟夫环问题，利用数学反推法，剩下最后一个数字求余为0，然后利用循环n-1次，让res=(res+m)%i不断求出下一个幸存数字的位置

## 第一个只出现一次的字符、

在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

示例:

s = "abaccdeff"
返回 "b"

s = "" 
返回 " "

思路：使用一个列表记录每个字符是否出现重复，后面遍历字符串，当字符在列表中没有值，设置为true,否则设置为false,后面遍历列表，找出第一个出现一次的字符

## 连续子数组最大和

输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

示例1:

输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

思路：利用动态规划思想，定义状态res[i]为nums[i]以nums[i]为结尾之和的最大值；当res[i-1]>0,res[i]=res[i-1]+nums[i];否则res[i]=nums[i];可以理解为res[i-1]是nums[i-1]结尾之和的最大值，碰到nums[i],考虑是否加上nums[i],先看res[i-1]是否大于0，如果大于0，说明nums[i-1]结尾的对nums[i]为结尾的有帮助，可以加上，否则还是保留以nums[i]为结尾的，不用加上nums[i-1]为结尾的

## 删除链表节点

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.

思路：判断头结点符合条件，直接放回p.next,否则遍历链表符合条件p.next=p.next.next返回head

## 构建乘积数组

给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

示例:

输入: [1,2,3,4,5]
输出: [120,60,40,30,24]

思路：将这道题想象成一个有五行1到5的表格，中间斜线都是1，只要计算上半三角形的值和下半三角形的值，计算下半，从i=1开始，b[i-1]就是上行的乘积*a[i-1],计算出b[i]的值；下半计算，j=a.length-2开始，tmp保留下行的乘积tmp*=a[j+1];b[j]*=tmp;最后返回b

## 平衡二叉树

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。

思路：计算左右子树的深度，如果两者绝对值之差大于2，返回-1；否则返回Math.max(m,n)+1;最后返回求深度函数是否为-1

## 包含min函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

示例:

MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.

思路：借助辅助栈，在push时，判断辅助栈中是否有值，没有直接加入x,有的话判断辅助栈最后一个值是否大于或等于x,是放入x;在pop时，判断辅助栈最后一个值是否等于pop()值，有就去掉辅助栈中最后一个值

## 对称二叉树

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3

示例 1：

输入：root = [1,2,2,3,4,4,3]
输出：true
示例 2：

输入：root = [1,2,2,null,3,null,3]
输出：false

思路：对称二叉树的满足条件:
1. L.val = R.val
2. L.left.val = R.right.val
3. L.right.val = R.left.val
根据这三个条件，如果!L&&!R return true;如果!L || !R || L.val!==R.val return false
不断递归recur(L.left, R.right) && recur(L.right, R.left);

## 不用加减乘除做加法

写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

示例:

输入: a = 1, b = 1
输出: 2

思路：使用 b=(a&b)<<1判断进位，a^=b异或相加，不断循环这个，直到d为0返回a

## 顺时针打印矩阵

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

示例 1：

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
示例 2：

输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]

思路：将这个矩阵分为上、左、下、右，遍历顺序为：从左到右，从上到下，从右到左、从下到上，不断遍历直到如下图：

打印方向|根据边界打|边界向内收缩|是否打印完毕
:-|:-:|:-:|-:
从左向右|左边界l ，右边界 r|上边界 t 加 1|是否 t > b
从上向下|上边界 t ，下边界b|右边界 r 减 1|是否 l > r
从右向左|右边界 r ，左边界l|下边界 b 减 1|是否 t > b
从下向上|下边界 b ，上边界t|左边界 l 加 1|是否 l > r

## 扑克牌中的顺子

从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

示例 1:

输入: [1,2,3,4,5]
输出: True

示例 2:

输入: [0,0,1,2,5]
输出: True

思路：利用max-min<5和Set解决；循环遍历，当遇到0跳过，set中有该值，直接返回，Math.max和Math.min确认最大值和最小值

## 0～n-1中缺失的数字

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

示例 1:

输入: [0,1,3]
输出: 2
示例 2:

输入: [0,1,2,3,4,5,6,7,9]
输出: 8

思路：使用二分法, if nums[middle]===middle, 那么要找的值一定在右边，否则一定在左边，到最后返回low

## 滑动窗口的最大值

给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。

示例:

输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

思路：用n[]存储递减序列的窗口，分为两个阶段:滑动窗口未满，n[]放入递减序列的值;滑动窗口已满，判断左边界的值是否等于n[0],j等于就将n[0]移除，n[]放入递减序列，res[]放入n[0]的窗口最大值

## 求1+2+。。。+n

求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

示例 1：

输入: n = 3
输出: 6
示例 2：

输入: n = 9
输出: 45

思路1：利用数学公式sum = n(n+1）/2；幂位运算(n**2 + n) >> 2

思路2： 利用递归，n>1&&total(n-1)实现不断递归，sum+=n,return sum

## 数组中数字出现的次数 II

在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

示例 1：

输入：nums = [3,4,3,3]
输出：4
示例 2：

输入：nums = [9,1,7,9,7,9,7]
输出：1

思路：根据每一bit对应的位数总和%3就是只出现一次的数字，所以cnt为每bit的位数总和，一共有32位，遍历32位，bit=1<<i,和遍历数组，判断bit&num[j]!=0,cnt++;说明这个就是唯一一个数字在该位数的bit值，然后使用res = res|bit,最后返回res

## 数组中数字出现的次数

一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

示例 1：

输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
示例 2：

输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]

思路：首先求出所有异或的值，这个值就是两个只出现一个数字的异或值，这两个值一定存在某个位数为0或1的情况，while !(ret & h) h<<=1,找出h是最后出现1的位数；然后分为两组，分别为0,1，遍历nums,判断a&num? a^=num: b^=num,返回[a,b]

## 深度复制链表

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

示例 1：

![](./picture/deepcopy.png)

输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]

思路：利用深度优先搜索(DFS),使用Map记录visited(访问过的节点），if visited.get(head), return visited.get(head);否则创建节点，记录到访问visited中，然后copy.next = dfs(head.next); copy.random = dfs(head.random),返回copy

## 礼物最大价值

在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

示例 1:

输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物

思路：动态规划，题中右下角(i,j)只能由(i-1,j),(i,j-1)两个位置得到，规定(i,j)为礼物在(i,j)的最大价值，
转移方程
(0,0):grid[0][0]保持不变；
(0,j):grid[0][j-1]+grid[0][j];
(i,0):grid[i-1][0]+grid[i][0];
(i,j):Max(grid[i-1][j], grid[i][j-1])+grid[i][j];

## 从上到下打印二叉树

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回：

[3,9,20,15,7]

思路：广度遍历二叉树（BFS),使用queue保存每个层次的节点，不断遍历queue，取出queue中的第一位，将该节点的值放入res,然后if head.left,将head.left放入queue；if head.right,将head.right放入queue;最后返回res

## 丑数

我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

思路：动态规划，由于dp[i]只是2、3、5的乘积可以得到，记录dp[i]为i位置最小的丑数，
转化方程dp[i]=
dp[a] min: a++ 
dp[b] min: b++
dp[c] min: c++
返回dp[n-1]

## 股票的最大利润

假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。

示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

思路：动态规划，记录profit为在第i天最大利润；minVal为i之前的最小值
转移方程：profit=Max(profit,prices[i]-minVal)

## 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

![](./picture/doubly_link.png)

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

![](./picture/doubly_link2.png)

思路：使用中序遍历二叉树得到有序节点；head保存双向链表，cur,pre分别为正要连接的双向节点，if !pre [pre.right, cur.left] = [cur, pre];中序遍历完，将[head.left, pre.right]= [pre, head];返回head

## 栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

示例 1：

输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
示例 2：

输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。

思路：借用辅助栈，用于记录出入栈的情况，可以根据poped[0]判断pushed到放入哪个取出，while stack.length && stack[stack.length-1]===poped[i]，stack.pop(),i++;返回!stack.length

## 从上到下打印二叉树 III

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [20,9],
  [15,7]
]

思路：思路和从上到下打印二叉树 II的例子一样，不过遇到level%2===0?res[level].push(head.val): res[level].unshift(head.val)

## 二叉树中和为某一值的路径

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

示例:
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1

返回:

[
   [5,4,11,2],
   [5,8,4,5]
]

思路：利用前序遍历，使用path[]存储所走路径，res[]存储结果，遍历时将节点val放进path,sum-=root.val,if sum=0 && !root.left && !root.right,将path放进res,注意要将path列表化，最后要取出path.pop()

## 把数组排成最小的数

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

示例 1:

输入: [10,2]
输出: "102"
示例 2:

输入: [3,30,34,5,9]
输出: "3033459"

思路：使用快排序，排序的条件：x+y>y+x: x大；x+y<y+x: y大；或者使用数组内置函数Array.sort

## 剪绳子

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例 1：

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

思路：贪心算法，尽可能多分数3和2才能使乘积最大，a：n//3;b:n%3;if b=0,pow(3,a);if b=1,pow(3,a-1)*4;if b=2, pow(3,a)*2

## 字符串排列

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

示例:

输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]

代码：

```

	var permutation = function(s) {
	    let c=[...s], res = [];
	    let len = c.length
	    function dfs(x){
	        if(x === len-1){
	            res.push([...c].join(""));
	            return;
	        }
	        let dict = new Set();
	        for(let i=x; i<len; i++){
	            if(dict.has(c[i])) continue;
	            dict.add(c[i]);
				// 固定x位字符串
	            [c[i], c[x]] = [c[x], c[i]];
	            dfs(x+1);
				// 恢复c的排序
	            [c[i], c[x]] = [c[x], c[i]]
	        }
	    }
	    dfs(0);
	    return res
	};
```

## 把数字翻译成字符串

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

示例 1:

输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"

思路：动态规划，tmp=s.slice(i-1, i);转移方程：f(i)
f(i-2)+f(i-1); "10"<=tmp<="25"
f(i-1);         其他

## 二叉搜索树第k个节点

给定一棵二叉搜索树，请找出其中的第k小的结点。例如，（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。

```

	function KthNode(pRoot, k)
	{
	    var index = 0;
	    function dfs(root){
	        if(root){
	            var node1 = dfs(root.left)
	            if(node1) return node1;
	            if(++index===k) return root;
	            var node2 = dfs(root.right)
	            if(node2) return node2;
	        }
	        return null
	    }
	    return dfs(pRoot);
	}
```

### 找出1到n中缺失的数字

给定一个长度为n-1的整形数组，数字的范围在1到n（无重复），其中有一个缺失的数字，写一段高效的程序找出该数字。

思路：利用异或运算，
任何数异或自己都等于0，x^x=0，任何数异或0都等于他自己x^0=x；
假如缺的为3。result = 1^2^4^5^N
第二次异或后 result = 1^2^4^5^N ^1^2^3^4^5^N = 0^3 = 3
时间复杂度：O(n) 空间复杂度：O(1)

```

	int getLose(int a[], int n)
	{
	    int t = 0;
	    for(int i =1; i<=n; i++)
	        t = t ^ i;
	    //最大值为n，缺失一个元素，则元素个数为n-2
	    for(int i=0; i<n-1; i++)
	        t = t ^ a[i];
	    return t;
	}
```

### 回文数字

在不使用额外的内存空间的条件下判断一个整数是否是回文数字
提示：
负整数可以是回文吗？（比如-1）
如果你在考虑将数字转化为字符串的话，请注意一下不能使用额外空间的限制
你可以将整数翻转。但是，如果你做过题目“反转数字”，你会知道将整数翻转可能会出现溢出的情况，你怎么处理这个问题？

思路：分别比较x的左边和右边的数字：不同，返回false；相同，则去掉左右两边的数字继续比较

```

	function isPalindrome( x ) {
	    // write code here
	    if(x<0) return false;
	    var div = 1;
	    while(x / div >= 10) {
	        div *= 10;
	    }
	    while(x>0){
	        let a = Math.floor(x/div);
	        let b = x % 10;
	        if(a != b){
	            return false;
	        }
	        x = Math.floor(x % div / 10);
	        div /= 100;
	    }
	    return true;
	}
```